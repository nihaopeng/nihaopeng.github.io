{"/docs/tutorial/ascend/mindspore_develop/index.html":{"title":"算子开发教程","content":"# 算子开发教程 [教程](https://www.hiascend.com/edu/courses?activeTab %E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91) ## cann架构 ![alt text](image.png) cann类似于cuda，因此底层都是基于bisheng/nvcc编译器的。 算子是通过bisheng编译成动态库的。 ## 硬件架构 ![alt text](image 1.png) > AI Core负责执行标量、向量和张量相关的计算密集型算子，包括三种基础计算单元：Cube（矩阵）计算单元、Vector（向量）计算单元和Scalar（标量）计算单元，同时还包含存储单元（包括硬件存储和用于数据搬运的搬运单元）和控制单元。 + 耦合架构 ![alt text](image 2.png) + 分离架构 ![alt text](image 3.png) > 在AI Core中，输入缓冲区之后设置了一个存储转换单元（Memory Transfer Unit，MTE）。这是达芬奇架构的特色之一，主要的目的是为了以极高的效率实现数据格式的转换。比如前面提到GPU要通过矩阵计算来实现卷积，首先要通过Im2Col的方法把输入的网络和特征数据重新以一定的格式排列起来。这一步在GPU当中是通过软件来实现的，效率比较低下。达芬奇架构采用了一个专用的存储转换单元来完成这一过程，将这一步完全固化在硬件电路中，可以在很短的时间之内完成整个转置过程。 这样看，专用硬件上的卷积加速算是走到头了，欸 ## bisheng Test 测试代码如下： ```c // 文件名QuickStartDemo.cce #include \"acl/acl.h\" #include <stdio.h> #include <stdlib.h> #ifdef ASCENDC_CPU_DEBUG #define __aicore__ #else #define __aicore__ [aicore] #endif #define BLOCKS 4 #define CACHELINE_SZ 64 // Define a kernel __global__ __aicore__ void foo(__gm__ uint8_t *Out, int Stride) { Out[block_idx * Stride] block_idx; } int main(int argc, char *argv[]) { aclInit(nullptr); aclrtSetDevice(0); aclrtStream stream; aclrtCreateStream(&stream); uint8_t ExpectedValue[] {0, 1, 2, 3}; uint8_t *OutputValue nullptr; aclrtMalloc((void **)&OutputValue, BLOCKS, ACL_MEM_MALLOC_HUGE_FIRST); uint8_t InitValue[BLOCKS] {0}; aclrtMemcpyAsync((void *)OutputValue, sizeof(InitValue), InitValue, sizeof(InitValue), ACL_MEMCPY_HOST_TO_DEVICE, stream); aclrtSynchronizeStream(stream); // Invoke a kernel foo<<<BLOCKS, nullptr, stream>>>(OutputValue, CACHELINE_SZ); uint8_t *OutHost nullptr; aclrtMallocHost((void **)&OutHost, BLOCKS * CACHELINE_SZ); aclrtMemcpyAsync(OutHost, BLOCKS * CACHELINE_SZ, OutputValue, BLOCKS * CACHELINE_SZ, ACL_MEMCPY_DEVICE_TO_HOST, stream); aclrtSynchronizeStream(stream); for (int I 0; I < sizeof(ExpectedValue) / sizeof(uint8_t); I++) { printf(\"i%d\\t Expect: 0x%04x\\t\\t\\t\\tResult: 0x%04x\\n\", I, ExpectedValue[I], OutHost[I * CACHELINE_SZ]); } aclrtFreeHost(OutHost); aclrtFree(OutputValue); aclrtDestroyStream(stream); aclrtResetDevice(0); aclFinalize(); return 0; } ``` 如果你对上面直接使用 `bisheng O2 cce soc version AscendXXXYY cce soc core type VecCore I$RT_INC L$RT_LIB lascendcl lruntime QuickStartDemo.cce o QuickStartDemo` 会告诉你架构不支持Ascend910B 但是，如果使用官方提供的脚本是可以编译通过的，那我们知道官方示例代码中存在异构代码，因此不可能使用gnu标准的gcc编译器，只有可能使用bisheng。 那我们通过编译官方示例，并查看对应的异构代码的编译命令 进入build目录执行 `make VERBOSE 1 grep add_custom.cpp` ![alt text](image 4.png) 找到编译器实际路径，我们再使用该路径编译器编译代码 还是架构不支持 测试以下编译指令 ```makefile cc1: /usr/local/Ascend/ascend toolkit/latest/compiler/ccec_compiler/bin/bisheng cc2: /usr/local/Ascend/ascend toolkit/latest/tools/ccec_compiler/bin/bisheng all: \t$(cc2) \\ \t I/usr/local/Ascend/ascend toolkit/latest/runtime/include \\ \t L/usr/local/Ascend/ascend toolkit/latest/runtime/lib64 g \\ \t O2 \\ \t cce soc version Ascend310P1 cce soc core type AICore \\ \t o QuickStartDemo.o \\ \tQuickStartDemo.cce ``` 使用310P1架构与AICore类型交叉编译，出现链接错误 ![alt text](image 5.png) 推测当前的编译器仅支持编译算子，并不支持编译为可执行文件（欸，懒得骂了） ## kernel算子开发(矩阵乘) ### 编译 clone算子example，然后执行sudo bash run.sh r npu v Ascend910B ### 编程范式 对于矩阵乘，其运算api为[Mmad](https://www.hiascend.com/document/detail/zh/CANNCommunityEdition/800alpha001/devguide/opdevg/ascendcopdevg/atlas_ascendc_10_0016.html?sub_id %2Fzh%2FCANNCommunityEdition%2F800alpha001%2Fapiref%2Fascendcopapi%2Fatlasascendc_api_07_0239.html#ZH CN_TOPIC_0000002082776405__section8213173433312)，但是要执行该操作，需要内存中的数据满足zz的格式。 ![范式](image 6.png) 上面是cube的运算流程，使用copyin，compute，copyout的运算流程，核函数中也遵循该流程。 更详细的流程是，先将输入矩阵传入A1，B1，如下： ![alt text](image 7.png) 接着将矩阵分块后存入A2，B2，如下: ![alt text](image 8.png) 然后进行矩阵运算，[Mmad](https://www.hiascend.com/document/detail/zh/CANNCommunityEdition/800alpha001/devguide/opdevg/ascendcopdevg/atlas_ascendc_10_0016.html?sub_id %2Fzh%2FCANNCommunityEdition%2F800alpha001%2Fapiref%2Fascendcopapi%2Fatlasascendc_api_07_0239.html#ZH CN_TOPIC_0000002082776405__section8213173433312)，再将结果输出到CO1，将分块后的结果融合成最终结果，然后存入CO1。 A2与B2内数据格式如下： ![alt text](image 12.png) 需要注意的是以上流程中的数据搬运都是通过队列排队实现，这样才能够实现流水线的效果。 ![alt text](image 13.png) 按照上图中的代码，即可实现流水，从逻辑上看，datacopy的工作必然由一个独立单元mte负责，mte与compute单元并行执行才能达到流水的目的。 假证也可推理，即，如果上述代码是串行执行，那么没必要使用queue，直接使用转置后的数据即可。 下面两图协同证明,datacopy任务指令序列在搬运单元中执行，搬运完后执行了setflag通知计算单元： ![alt text](image 15.png) ![alt text](image 14.png) ### 调用 + 创建上下文 ![alt text](image 9.png) + 分配设备空间 ![alt text](image 10.png) + 调用内核函数 ![alt text](image 11.png)"},"/docs/tutorial/ascend/benchTest/index.html":{"title":"ascend bench test","content":"# ascend bench test ## work target 围绕mindspore graphlearning 使用官方提供的profile工具，做一些测试 1.运行GCN算法，使用reddit数据集（也可以考虑多个数据集，或者变换隐藏层维度），对比昇腾与GPU的性能差异（epoch运行时间）。 mindspore 即能跑GPU也能跑昇腾 2.profile一下mindspore graphlearning 在运行GCN算法时，不同算子在不同计算单元（CUBE/VECTOR/Scalar/AICPU）上的执行时间占比，profile工具好像还提供可视化算子流水的功能，能可视化一段时间内，是哪个算子在运行 ## 安装Graph leaning >! 一定要先进行这一步，如果你先安装mindspore，安装gl会进行环境检查，然后告诉你平台不对。（逆天bug） 记得先使用镜像安装requirements.txt中的依赖，不然后面自动下载依赖很慢 [官网教程](https://www.mindspore.cn/graphlearning/docs/zh CN/r0.2/mindspore_graphlearning_install.html) cuda gpu版本安装，需要注意环境问题,python只能是3.7 ![alt text](image 6.png) >! 血泪教训，记得添加CUDA_HOME环境变量，mindspore是根据cuda_home的变量来寻找cudatoolkit的位置的，官网没说，乐 ## 安装mindspore [官网教程](https://www.mindspore.cn/install/) ## gcn 不讨论其公式原理，和拉普拉斯矩阵相关，傅里叶那一套的数学转换方法，挺杂乱的，这里直接给出算法原理 ![alt text](image 1.png) 如上图，一个layer中的聚合方式，邻接矩阵矩阵乘节点特征矩阵达到聚合的目的。 对计算结果归一化，使用度矩阵（degree）乘上上面的计算结果。 但是如果仔细观察就会发现，该归一化的作用范围仅有行，例如图中的1/3，被1/3乘的只有横着的一行，也就是单向边，想要对列也起作用，那么在另一边也乘一个度矩阵逆即可。 但是乘了两次，所以使用$D^{ 1/2}$来减轻归一化的程度（不严谨说法） 上面的过程用公式表述为 $$D^{ 1/2}AD^{ 1/2}X$$ 在神经网络中还会乘上一个权重矩阵W,再激活一下，加个偏置，标准做法了 $$ReLU(D^{ 1/2}AD^{ 1/2}XW+B)$$ 以上就是一层的计算过程了，实际上一直到计算归一化的过程都是可以进行简化的。也就是进行融合。 ## 数据集 ### reddit [下载地址](https://data.dgl.ai/dataset/reddit.zip) 读取数据集，该数据集不像corav2几乎给了所有的列名，所以需要转换一下。 很坑的一点是，官网说Reddit类返回的adj_coo是ndarray类型，结果一打印，发现是scipy的coo_matrix格式，他们官网的文档完全是在误导人。 ![alt text](image 2.png) 数据读取转换代码如下： ```python class GraphReddit: \"\"\"Full training numpy dataset \"\"\" def __init__(self, data_path: str) > None: graph Reddit(data_path) self.x ms.Tensor(graph.node_feat,dtype ms.float16) self.y ms.Tensor(graph.node_label, ms.int32) self.train_mask graph.train_mask self.test_mask graph.test_mask self.n_nodes graph.node_count self.n_edges graph.edge_count self.g GraphField(ms.Tensor(graph.adj_coo.row, dtype ms.int32), ms.Tensor(graph.adj_coo.col, dtype ms.int32), int(self.n_nodes), int(self.n_edges)) self.n_classes int(graph.num_classes) in_deg np.zeros(shape self.n_nodes, dtype np.int64) out_deg np.zeros(shape self.n_nodes, dtype np.int64) for r in graph.adj_coo.row: out_deg[r] + 1 for c in graph.adj_coo.col: in_deg[c] + 1 self.in_deg ms.Tensor(in_deg, ms.int32) self.out_deg ms.Tensor(out_deg, ms.int32) print(\"data prepared\") ``` ok,那我开骂了，那两个for语句给我整笑了，如果出入度形状对不上，后面就会报错（alloc error gather）的问题，报错牛头不对马嘴。 最离谱的是，python的for慢地吃屎，numpy的优势属于是荡然无存了，样例里面写出两个for我能感觉到写这段代码的人的无语了。 ## 模型 还得吐槽 为什么一定需要套一个Datanet的inference层？？不是很明白这么做的意义是什么 ![alt text](image 3.png) ## 性能监测 1，使用profiler的api 在训练代码前添加 `profiler Profiler(profiler_level ProfilerLevel.Level0,output_path \"./profiler\",profile_memory True,hbm_ddr True)` 训练结束后添加 `profiler.analyse()` but我的没有生效，生成的数据无法通过mindinsight查看 2，使用环境变量 在bashrc中添加 ![alt text](image 4.png) 再次运行训练代码, 通过`mindinsight start port 8003 summary base dir root_dir` 即可查看数据可视化如下： ![alt text](image 5.png) ## 性能分析 由于mindspore gpu下跑gcn整图训练reddit数据集会爆（gpu4090，24GB显存），所以我们使用cora_v2进行对比 Ascend ![alt text](image 7.png) CPU ![alt text](image 8.png) 基本都是计算各算子的时间占比，一方面不熟悉这些算子功能，另一方面做加速对功能不敏感，但是对实现敏感，所以这里暂时转向[算子开发验证](../mindspore_develop/index.html),还有一部分原因是，其文档过于杂乱，有部分算子甚至是在mindspore版本1.3中才有，有一些又是使用的tf的接口。"},"/docs/tutorial/linux/dev_tree/index.html":{"title":"linux设备树","content":"# linux设备树 ## 问题 device与driver分离 前者作为硬件信息的描述，后者作为驱动代码，都会被编译为ko文件进入内核，但是硬件种类增多将会产生大量关于硬件描述的信息，但是不是所有的都用得上，出现大量垃圾代码。 ## 解决 用设备树的方式，实际上也就是将device的代码分离出来，不再进入内核，通过bootloader传给内核。类似反射的工作方式。 ## 基础"},"/docs/tutorial/linux/frp/frp.html":{"title":"","content":"> # frp穿透 >借助sakura frp建立内网穿透 ## 内网穿透浅析 现在假设我们在电脑上建立http server进程，该进程绑定到2345端口。 那么我们如果想让外部设备访问该服务，要么将电脑置于公网上，也就是获取一个公网ip。 要么借助中间人，让外部设备通过中间人访问，也就是内网穿透技术，我更愿意将之称为代理（proxy）的一种。 原理如下： <div style \"text align:center;\"><img src \"v2 5b95727dc00913e1675b981f5adcb72b_1440w.jpg\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> 显而易见，当外部设备访问外网服务器的ip:port，例如101.70.105.150:4598时，该服务器上运行的frps程序将接受你所有的请求，并将该请求转发给你的局域网机器（公网机器能给局域网转发是因为局域网机器主动与公网机器建立了长连接），局域网机器获取请求返回响应，公网机器将响应返回给请求者。 ## sakura frp ### 建立通道 进入[sakura](https://www.natfrp.com/user/)官网,注册并认证。 点击`服务` >`隧道列表` >`创建隧道` <div style \"text align:center;\"><img src \"QQ20241213 002213.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> 到这一步所看见的列表就是能选择的公网机器列表。 <div style \"text align:center;\"><img src \"QQ20241213 002331.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> 一般选tcp或者udp协议，前者更常用（建网站），后者主要用于游戏服务器的搭建。 <div style \"text align:center;\"><img src \"QQ20241213 002506.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> 最重要的就是本地端口的选择，也就是填你在局域网机器建立的服务绑定的端口，以这里的例子，也就是2345。然后点击完成。 点击`服务` >`软件下载` >`frpc` >选择架构 >`下载` 将下载到的二进制文件放到我们建立服务的局域网服务器。 <div style \"text align:center;\"><img src \"QQ20241213 003001.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> 在以上图中复制参数，并在局域网服务器上运行 `./frpc f 你复制的参数` 当打印出公网ip，那么穿透成功。 ## 域名上网 ### 申请域名 ### 域名备案 ### ssl证书 1,华为云买一个免费的，选最后一个类型，供应商选di 2，添加记录集，类型TXT验证 3，将证书下载到frp工作目录，frp的证书放在哪里，你就把新证书放在哪里，证书的前缀由域名决定。 ![alt text](image.png) 4，frp的工作目录由执行路径决定，或者由service的workingDirectory决定： ![alt text](image 1.png) 5，完成更换后直接重启frp服务即可"},"/docs/tutorial/linux/service/service.html":{"title":"linux service建立","content":"# linux service建立 ## 创建service文件 <div style \"text align:center;\"><img src \"QQ20241213 003441.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> 首先在`/etc/systemd/system/`目录下创建一个example.service文件，文件中填入上面的内容。 需要更改的部分： + 如果是不依赖网络的服务，那么可以将Requires那一行去掉 + ExecStart改为你需要执行的命令 + User代表你以什么用户运行该进程，如果需要高权限，可以改为root + WorkingDirectory代表你的运行该程序时将会进入哪个目录。 + StandardOutput代表进程的标准输出重定向到哪个文件 + StandardError代表标准错误输出重定向到哪个文件 ## 启动service 重新加载所有的service，也包括我们新加入的service文件。 `sudo systemctl daemon reload` 启动服务 `sudo systemctl start example.service` 查看服务状态 `sudo systemctl status example.service` 如果出现activating，那么启动成功，此时该进程将被加入守护进程与开机自启。 ## 关闭服务 `sudo systemctl stop example.service` ## 删除服务 `sudo rm /etc/systemd/system/example.service` `sudo systemctl stop example.service`"},"/docs/tutorial/python/pyside6/index.html":{"title":"pyside6 开发","content":"# pyside6 开发 ## 安装 `pip install pyside6` ## 打开pyside designer `pyside6 designer` ## ui转python代码 `pyside6 uic untitled.ui > widget.py` ## 实例化ui ```python class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() # 创建 UI 实例并设置到当前窗口 self.ui Ui_MainWindow()#这个Ui_MainWindow就是我们创建的ui self.ui.setupUi(self) # 添加自定义逻辑 self.ui.pushButton.clicked.connect(self.on_button_clicked) def on_button_clicked(self): print(\"按钮被点击了！\") if __name__ \"__main__\": app QApplication(sys.argv) mainWindow MainWindow() mainWindow.show() app.exec() ``` ## 创建托盘(创建菜单) ```python # 创建系统托盘图标 self.tray_icon QSystemTrayIcon(self) self.tray_icon.setIcon(QIcon(\"icon.png\")) # 设置托盘图标，替换为你的图标路径 # 创建托盘菜单 self.tray_menu QMenu() # 添加显示窗口选项 show_action QAction(\"Show Window\", self) show_action.triggered.connect(self.show_window) self.tray_menu.addAction(show_action) # 添加退出选项 exit_action QAction(\"Exit\", self) exit_action.triggered.connect(self.close_application) self.tray_menu.addAction(exit_action) # 将菜单绑定到托盘图标 self.tray_icon.setContextMenu(self.tray_menu) # 显示托盘图标 self.tray_icon.show() ``` ## 窗口属性 + 窗口置底 ```python self.setWindowFlags(Qt.WindowStaysOnBottomHint) ``` + 窗口无边框化 ```python self.setWindowFlags(Qt.FramelessWindowHint) ``` + 隐藏任务栏图标 ```python self.setWindowFlags(Qt.Tool) ``` ## 动态插入子部件 ```python new_todo Todo(self) new_todo.setText(text) self.ui.lineEdit.clear() self.ui.scrollVLayout.insertWidget(1,new_todo) ``` ## 背景窗口圆角 ```python def paintEvent(self, event): # 创建一个 QPainter 对象并指定绘制设备为当前窗口 painter QPainter(self) # 设置绘制选项为反锯齿，使绘制的图形边缘更加平滑 painter.setRenderHint(QPainter.RenderHint.Antialiasing) # 设置画刷颜色为白色 painter.setBrush(QBrush(QColor(255, 255, 255))) # 设置画笔颜色为透明，即不绘制边框线 painter.setPen(Qt.GlobalColor.transparent) # 获取当前窗口的矩形区域 rect self.rect() # 绘制圆角矩形，圆角半径为 15 painter.drawRoundedRect(rect, 15, 15) \"\"\" 通过遮罩设置窗口为圆角矩形 \"\"\" path QPainterPath() rect QRect(0, 0, self.width(), self.height()) radius 15 # 圆角半径 path.addRoundedRect(rect, radius, radius) # 使用 QRegion 进行裁剪 region QRegion(path.toFillPolygon().toPolygon()) self.setMask(region) ``` 不设置遮罩将会出现四个黑角，反正通用框架基于系统的窗口管理器必定出现许多问题 ## QCharts 太杂了，不太好说 ## QSS ```css QPushButton { background color: #4CAF50; /* 设置按钮背景颜色 */ color: white; /* 设置按钮文本颜色 */ border: none; padding: 5px 10px; } QPushButton:hover { background color: #45a049; /* 设置按钮悬停时的背景颜色 */ } ``` ## 弹出输入框 ```python # 创建一个 QInputDialog input_dialog QInputDialog(self) input_dialog.setWindowTitle(\"修改文本\") input_dialog.setLabelText(\"请输入新的文本：\") input_dialog.setTextValue(self.text()) # 设置默认值为当前文本 # 显示对话框并获取用户输入 if input_dialog.exec() QInputDialog.Accepted: new_text input_dialog.textValue() if new_text: self.setText(new_text) ``` ## 本文设置删除线 ```python def setStrike(self,ifstrikeout:bool): font self.font() font.setStrikeOut(ifstrikeout) # 移除删除线 self.setFont(font) ``` ## 将窗口嵌入桌面 ```python def set_desktop_window(self): # 获取桌面窗口的句柄 hwnd ctypes.windll.user32.FindWindowW(\"Progman\", \"Program Manager\") if hwnd: # print(\"setdesktopparent\") # 获取当前窗口的句柄 win_hwnd self.window.winId() # 将当前窗口设置为桌面窗口的子窗口 ctypes.windll.user32.SetParent(win_hwnd, hwnd) ``` 需要注意的是，嵌入桌面后，如果使用setStyleSheet(\"background: transparent;\")，背景将会变为纯黑（windows，预估是windows窗口管理器搞的鬼） 如果setAttribute(Qt.WA_TranslucentBackground),窗口上的空间将不再发生变化（难蚌） 解决！！！ ```python 查找到program manager窗口的句柄 progman_hwnd ctypes.windll.user32.FindWindowW(\"Progman\", \"Program Manager\") if not progman_hwnd: print(\"Failed to find Progman window\") return # 2. 发送 0x52C 消息，触发桌面窗口重新排列 ctypes.windll.user32.SendMessageW(progman_hwnd, 0x52C, 0, 0) # 3. 查找 WorkerW 窗口 self.workerw_hwnd ctypes.c_int(0) def enum_windows_callback(hwnd, lParam): # 查找 WorkerW 窗口 if ctypes.windll.user32.FindWindowExW(hwnd, None, \"SHELLDLL_DefView\", None): # self.workerw_hwnd ctypes.windll.user32.FindWindowExW(None, hwnd, \"WorkerW\", None) self.workerw_hwnd hwnd return True # 将 Python 回调函数转换为 C 回调函数 # 定义回调函数类型 WNDENUMPROC ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int)) enum_windows_proc WNDENUMPROC(enum_windows_callback) # 枚举所有窗口 ctypes.windll.user32.EnumWindows(enum_windows_proc, 0) if not self.workerw_hwnd: print(\"Failed to find WorkerW window\") return # 4. 将当前窗口设置为 WorkerW 的子窗口 win_hwnd self.window.winId() ctypes.windll.user32.SetParent(win_hwnd, self.workerw_hwnd) # 5. 确保窗口可见 ctypes.windll.user32.ShowWindow(win_hwnd, 1) # SW_SHOWNORMAL ``` 最根本的问题在于，有部分设备的program manager与worker是分离的，其中一个worker是管理桌面图标的，另一个worker是透明背景，而program manager是桌面总窗口。 如下的spy视图 ![alt text](image.png) 我们之前是将我们的窗口加入program manager，这会造成worker的层级在我们窗口之上，我们的就被挡住了，现在我们先向program manager发送0x52c将program manager拆出workerw，此时将我们的窗口作为workerw的子窗口，注意，需要时包含shelldlldelview的workerw，否则也会被遮挡。如果想做桌面壁纸，那就将窗口作为另一个worker的子窗口。添柴！"},"/docs/tutorial/ascend/problems/index.html":{"title":"910B1相关问题","content":"# 910B1相关问题 ## 环境 910A环境变量： ![alt text](image 2.png) 910B1环境变量： ![alt text](image 3.png) ## 分支代码 代码位置 + 910A /mnt/nvme0/pengyt/projects/matrix/optimize/ascendc + 910B1 /mnt/nvme0/pengyt/project/ascendc 执行命令： `./batch_run.sh batch_config` ### master分支 实现简单的分块矩阵乘 + 按行列组为aicore分配计算任务 + 组内再切分以外积的方式进行计算 + 计算结果在CO1累加，最后经CO2搬出到GM 如下图： ![alt text](image.png) 910A执行结果： ![alt text](image 1.png) 910B1执行结果： ![alt text](image 7.png) 分析： 注释掉代码主逻辑，进行一次分配与释放， ![alt text](image 11.png) 出现如下错误： ![alt text](image 12.png) 注释掉所有逻辑： ![alt text](image 14.png) 发现调用kernel就在报错： ![alt text](image 15.png) ### smaller_tile分支 提高第二次切分的细粒度，能够充分利用L0缓存，而不必受限于第一次切分的矩阵形状 + 按行列组为aicore分配计算任务 + 组内再切分以外积/内积的方式进行计算 + 计算结果在CO1累加，最后经CO2搬出到GM 如下图： ![alt text](image 4.png) 910A执行结果： ![alt text](image 5.png) 910B1执行结果： ![alt text](image 6.png) ### cvAgg_dataTransInhost分支 + 按行列组为aicore分配计算任务 + cube内按照master方式进行计算 + vec的任务分配由eq_core_num参数决定，计算公式为 $$task \\frac{group\\_sum}{block\\_num + eq\\_core\\_num} \\times eq\\_core\\_num$$ 如下图： ![alt text](image 8.png) 910A执行结果： ![alt text](image 9.png) 910B1执行结果： ![alt text](image 10.png)"},"/docs/tutorial/blkrv/quickstart/quickstart.html":{"title":"快速开始","content":"# 快速开始 ## docker（推荐） 非root用户以下所有指令都应在指令前添加sudo赋权。 + 拉取镜像 `docker pull docker.1ms.run/cnameless/blkrv` + 运行镜像 `docker run itd p 59066:22 p 59067:8000 name blkrv docker.1ms.run/cnameless/blkrv:1.0 /bin/bash` 此时宿主机的59066端口映射到容器的22端口，用于ssh连接，59067映射到8000端口用于访问可视化服务 + 安装并启动ssh服务 `docker exec blkrv apt install y openssh server && docker exec blkrv service ssh start` + 连接镜像 [windterm（推荐）](https://github.com/kingToolbox/WindTerm/releases) 如果在windows上使用虚拟机，那么此时需要使虚拟机作为代理服务器连接docker，代理服务器配置如下： ![alt text](image.png) 主机ip为虚拟机地址，跳转服务器的ip为docker的ip地址。 虚拟机直接进入docker `docker exec it blkrv /bin/bash` vscode 配置ssh连接配置如下： ```config Host j2docker HostName [docker镜像ip] User root Port [docker镜像ssh端口] ProxyJump user@[虚拟机ip]:[虚拟机ssh端口] ``` docker镜像ip获取： `docker exec blkrv apt install y net tools && docker exec blkrv ifconfig` ## 手动安装（推荐使用docker的方式，节省时间） [verilator编译教程](../tools/verilator/verilator.html) [riscv编译链编译教程](../tools/riscv elf unknown gcc/gcc.html) [fltk安装教程（可选）](../tools/fltk/fltk.html) ## 编译＋执行 + 递归克隆项目 `git clone recursive https://gitee.com/helloyutao/blkrv.git` + 编译运行项目 cli `make` 带图形化界面（依赖flkt库） `make ENABLE_GPU 1` 需要注意该编译方式标准输入将会被重定向到图形化窗口，输入将不被命令行接收。"},"/docs/tutorial/blkrv/index.html":{"title":"BLKRv","content":" title: BLKRv <html> <head> <meta charset \"utf 8\"> <style> .expandable list { width: 300px; margin: 20px; font family: Arial, sans serif; } details { border: 1px solid #ddd; border radius: 5px; margin bottom: 10px; padding: 10px; background color: #f9f9f9; } summary { font weight: bold; cursor: pointer; padding: 8px; list style: none; position: relative; /* 为图标定位提供参考 */ } summary:: webkit details marker { display: none; } summary:after { content: \"▼\"; position: absolute; right: 10px; font size: 12px; transition: transform 0.3s ease; /* 添加旋转动画 */ } details:hover { background color: #f5f8ff; /* 浅蓝色背景 */ border color: #c2d6ff; /* 边框高亮 */ box shadow: 0 4px 12px rgba(0,0,0,0.1); /* 立体阴影 */ transition: all 0.3s ease; /* 平滑过渡 */ } summary:hover { color: #1a73e8; /* 文字变蓝 */ background color: #e6eeff; /* 标题背景渐变 */ } a.link { display: block; /* 设置为块级元素[1,2](@ref) */ padding: 12px 15px; margin: 8px 0; background color: #fff; border radius: 4px; color: #1a73e8; text decoration: none; transition: all 0.3s ease; border: 1px solid #eaeaea; box shadow: 0 2px 4px rgba(0,0,0,0.05); } a.link:hover { background color: #f5f8ff; /* 悬停背景色[5](@ref) */ transform: translateY( 2px); box shadow: 0 4px 8px rgba(0,0,0,0.1); border color: #c2d6ff; } a.link:active { background color: #e6eeff; /* 点击效果[4](@ref) */ transform: translateY(0); } </style> </head> <body> <div class \"expandable list\"> <details> <summary>blkrv</summary> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\quickstart\\quickstart.html\">quickstart</a> <details> <summary>进阶</summary> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\进阶\\寄存器\\README.html\">寄存器</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\进阶\\外设\\README.html\">外设</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\进阶\\MMU\\README.html\">MMU</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\进阶\\RIB BUS\\README.html\">RIB BUS</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\进阶\\wrapper\\README.html\">Wrapper</a> </details> <details> <summary>tools</summary> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\tools\\fltk\\fltk.html\">fltk</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\tools\\mingw\\mingw.html\">mingw</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\tools\\riscv elf unknown gcc\\gcc.html\">riscv交叉编译链</a> <a class \"link\" href \"\\docs\\tutorial\\blkrv\\tools\\verilator\\verilator.html\">second Tier memory</a> </details> </details> </details> </div> </body> </html>"},"/docs/tutorial/blkrv/tools/fltk/fltk.html":{"title":"fltk","content":"# fltk ## ubuntu + 官网下载源码 https://www.fltk.org/software.php + 解压文件 `tar xvf fltk .tar.gz` + 编译 `./configure enable debug enable shared enable threads enable xdbe enable xft` + 安装 `sudo make install` ## windows ### 安装mingw64 [mingw教程](../mingw/mingw.html) ### 安装cmake 略~ ### 安装fltk + 1，下载源码 + 2，启动cmake gui，也可以直接CLI configure，配置选择源码路径以及make生成路径 <div style \"text align:center;\"><img src \"./QQ20241204 180724.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> + 3，点configure配置mingw编译器，只用gcc和g++，配置安装路径 + 4，点generate生成makefile + 5，进入make生成路径文件夹，执行mingw32 make install ### 使用 示例代码test.cpp ```c++ #include <FL/Fl.H> #include <FL/Fl_Window.H> #include <FL/Fl_Box.H> int main(int argc, char **argv) { Fl_Window *window new Fl_Window(300,180); Fl_Box *box new Fl_Box(20,40,260,100,\"Hello, World!\"); box >box(FL_UP_BOX); box >labelsize(36); box >labelfont(FL_BOLD+FL_ITALIC); box >labeltype(FL_SHADOW_LABEL); window >end(); window >show(argc, argv); return Fl::run(); } ``` makefile文件 ```makefile all:test.cpp \tg++ test.cpp o fltk static \\ \t LC:\\myfile\\softwares\\fltk\\installed\\lib \\ \t lfltk \\ \t lole32 luuid lgdiplus lcomdlg32 lwinspool lgdi32 lws2_32 lComctl32 \\ \t IC:\\myfile\\softwares\\fltk\\installed\\include ``` 后边儿一大堆库是mingw带的系统库，写一般程序用不到，gui库是这样的，乐。 **注意到那个Comctl32，没有的话会报错，报的错问gpt会让你添加user32，没卵用，那个库是在微软官网找到的。** 执行`mingw32 make`编译得到fltk可执行文件，执行效果如下： <div style \"text align:center;\"><img src \"./QQ20241204 180826.png\" style \"zoom:70%;border radius: 10px;border:2px solid #23D18B;padding:10px\"/></div> ### 在blkrv中使用 blkrv仅支持在linux上运行，fltk用于模拟显示器，因此，如果需要显示图形化内容，请使用`make clean && make ENABLE_GPU 1`以开启图形化显示。"},"/docs/tutorial/blkrv/tools/mingw/mingw.html":{"title":"mingw编译","content":"# mingw编译 ## 下载mingw 下载mingw预编译版本（联系作者获取预编译文件） 将mingw的bin目录加到path环境目录，很多小朋友的os换win11，这里就不给配置环境变量的教程了。 加到环境变量后，win+r输入cmd再按enter，控制台输入gcc v，有输出说明配置成功。"},"/docs/tutorial/blkrv/tools/riscv-elf-unknown-gcc/gcc.html":{"title":"riscv交叉编译链","content":"# riscv交叉编译链 ## 依赖安装 顺序执行以下： [download gmp](https://gmplib.org/) ```bash tar xvjf gmp 6.2.1.tar.bz2 cd gmp 6.2.1/ ./configure make make install ``` [download mpfr](https://ftp.gnu.org/gnu/mpfr/) ```bash tar xvjf mpfr 4.1.0.tar.bz2 cd mpfr 4.1.0/ ./configure make make install ``` [download mpc](https://www.multiprecision.org/mpc/download.html) ```bash tar xvzf mpc 1.2.1.tar.gz cd mpc 1.2.1/ ./configure make make install ``` [download gettext](https://mirrors.aliyun.com/gnu/gettext/) ```bash tar zxvf gettext.tar.gz cd gettext ./configure make make install ``` ## 安装 以下两种方式 + 获取预编译版本 1,通过网盘分享的文件：riscv32.tar.gz 链接: https://pan.baidu.com/s/1pf0ikqstdLKcauD90w3KeQ?pwd b3vt 提取码: b3vt 2,`tar zxvf riscv32.tar.gz` + 手动编译 1,`git clone recursive https://github.com/riscv/riscv gnu toolchain` fine,你可以选择不递归下载，后续编译会自动下载相关内容。 2,`cd riscv gnu toolchain` 3,`./configure prefix /opt/riscv32 with arch rv32i with abi ilp32` 上面prefix代表编译完后的文件存放路径， with arch rv32i代表支持riscv 32位 整数指令集，abi是调用规范，使用ilp32，不支持浮点。 4,`make` ### 添加环境变量 1,`vim ~/.bashrc` + 采用手动编译的，末尾增加`export PATH /opt/riscv32/bin:$PATH$`，也就是上面的prefix。 + 采用预编译包的，末尾添加`export PATH /path/to/riscv/bin:$PATH$`。/path/to/riscv/也就是riscv文件夹路径 2,按ESC键，输入:wq退出vim编辑器，冒号别少了。 3,`source ~/.bashrc` 4,运行`riscv32 unknown elf gcc version`查看是否有输出"},"/docs/tutorial/blkrv/tools/verilator/verilator.html":{"title":"verilator安装","content":"# verilator安装 ## linux 1,`git clone https://github.com/verilator/verilator` 2,`sudo apt install autoconf` 3,`autoconf` 4,`cd verilator && ./configure` 5,`make j n`n为主机的核数 6,`sudo make install` 7,`verilator`测试是否有输出"},"/docs/tutorial/blkrv/进阶/MMU/index.html":{"title":"MMU","content":"# MMU ## 工作流程 + 启动 当satp寄存器值低12位不为零 + 工作 1，检查tlb快表 2，如果命中则直接返回物理地址。 3，如果未命中则经过如下流程进行虚拟地址转换 ![alt text](image.png) + 未命中 此处功能可扩展 当前对于未命中的处理为： 1，如果tlb一级快表已满，则删除快表第一项，新表项插入末尾 2，如果未满，则插入末尾"},"/docs/tutorial/blkrv/进阶/RIB-BUS/index.html":{"title":"BUS","content":"# BUS 在blkrv中，rib总线仅具备地址分发与数据传输的作用。即区分设备以及作为数据的中间代理。 ## 地址分发 在rib中规定了各设备的地址空间 如果需要进行扩展，即设备的注册，可以通过csr寄存器结合内存的方式，进行热插拔等扩展。 rib中的分发函数如下： ```c++ #define DISPATCH(n,dev) do { \\ this >s##n##_req 1; \\ this >s##n##_addr addr dev##_start_addr; \\ this >s##n##_write_data top >write_data; \\ this >s##n##_we top >we; \\ this >s##n##_mem_op_type top >mem_op_type; \\ } while(0) ``` n为设备端口号，dev为设备名 当判断地址属于某一个设备时，将会调用上面的函数进行地址分发，并将相应的数据传输给相应的设备。 ## 数据传输 数据的正向传输被包含在地址分发当中，数据从设备的响应如下： ```c++ #define SET_INT(n) top >int_port##n this >int_port##n #define SET_READ_DATA(n) if(REQ(n)){top >read_data READ_DATA(n);} ``` 在devices处理完数据后，需要调用setflag将响应的数据或者信号（如中断信号）响应给cpu。"},"/docs/tutorial/blkrv/进阶/wrapper/index.html":{"title":"wrapper","content":"# wrapper 该模块用于启动cpu，也是启动整个系统的运行 wrapper的逻辑代码位于blkrv/rtl/csrc/main.cpp ## verilator + 初始化上下文 ```c++ VerilatedContext* contextp new VerilatedContext; contextp >commandArgs(argc, argv); Vtop* top new Vtop{contextp}; VerilatedVcdC* tfp new VerilatedVcdC; contextp >traceEverOn(true); ``` + 打开trace跟踪 ```c++ top >trace(tfp, 0); tfp >open(\"wave.vcd\"); ``` + 模拟 ```c++ top >eval() ``` ## devices（外设） + 初始化设备 ```c++ extern devices my_devices;//已在devices.cpp文件中声明为全局变量 ``` + 初始化监测器 ```c++ monitor* my_monitor; if(argc> 2)//传入性能数据存储文件路径 my_monitor new monitor(1<<28,argv[1]); else my_monitor new monitor(1<<28,\"../data.txt\"); ``` + 片上系统工作流 ```c++ for(;;i++){//死循环 top >clk 0;//时钟在0，1间来回切换 top >eval();//模拟 my_rib.dispatch(top,my_mmu.convert(top,&my_devices));//mmu转换虚拟地址后，将物理地址传入rib总线，决定传入指定的设备 my_monitor >process(&my_rib,&my_mmu,main_time);//监测器采集相关数据。 if(my_devices.process(&my_rib,i)){//外设接受信号 break;//如果外设返回1，则代表出现关机信号。 } my_rib.set_flag(top);//将外设的信号传回，由rib传给cpu top >clk 1; top >eval(); } ``` ## 全部代码 + ```c++ #include<verilated.h> #include<verilated_vcd_c.h> #include \"Vtop.h\" #include \"devices.h\" #include \"mmu.h\" #include \"monitor.h\" extern vluint64_t main_time; extern devices my_devices; extern rib my_rib; extern mmu my_mmu; int main(int argc, char** argv, char** env) { std::cout<<\"\\033[3;1;31mstarting sim...\\033[0m\"<<std::endl; VerilatedContext* contextp new VerilatedContext; contextp >commandArgs(argc, argv); Vtop* top new Vtop{contextp}; VerilatedVcdC* tfp new VerilatedVcdC; contextp >traceEverOn(true); top >trace(tfp, 0); tfp >open(\"wave.vcd\"); std::cout<<\"start initializing devices...\"<<std::endl; std::cout<<\"$init monitor\"<<std::endl; monitor* my_monitor; if(argc> 2) my_monitor new monitor(1<<28,argv[1]); else my_monitor new monitor(1<<28,\"../data.txt\"); clock_t start,end; start clock(); top >clk 0; int i 0; for(;;i++){ top >clk 0; top >eval(); my_rib.dispatch(top,my_mmu.convert(top,&my_devices)); my_monitor >process(&my_rib,&my_mmu,main_time); if(my_devices.process(&my_rib,i)){ break; } my_rib.set_flag(top); top >clk 1; top >eval(); } end clock(); printf(\"ticktimes:%d,timecost:%f s\\ndevices shuting down...\\n\",i,((double)(end start))/CLOCKS_PER_SEC); delete top; tfp >close(); delete contextp; return 0; } ```"},"/docs/tutorial/blkrv/进阶/外设/index.html":{"title":"外设","content":"# 外设 ## 虚拟抽象 ![alt text](image.png) ## 协议 所有的外设均是经过简化的设备，对于现实设备不具备参考价值，我们自定义了大量的控制寄存器与数据寄存器等。 + bios 说明 pc寄存器初始为0，程序将从bios的0地址开始执行。 地址空间 0x00000000 0x00100000 + ram 说明 可扩展内存控制器，需要注意某些耦合设备实现，例如ram等。 地址空间 0x00100000 0x10100000 + keyboard 地址空间 0x10100000 0x10200000 driver 键盘按下时产生中断，0x10100000地址处将会存储三个字符缓存。 + screen（字符输出设备） 地址空间 0x10200000 0x20200000 driver 0x10200003写入1时触发输出，screen设备将会将0x10200004后的字符输出到宿主机终端。 + gpu 说明 gpu设备并不具备通用并行计算能力，但是可以扩展，绘图功能被限制，也可以扩展 该设备贴图时为了性能需求，将会直接从flash读取文件内容，这与文件系统强绑定。 地址空间 0x20200000 0x30200000 driver 0x20200000为控制寄存器地址 写入信号对应功能数据寄存器功能与地址偏移 1绘制文字4:x;8:y;12:r;16:g;20:b;24:font_size 2绘制三角形4:x0;8:y0;12:x1;16:y1;20:x2;24:y2;28:r;32:g;36:b 3刷新屏幕 4绘制jpg4:x;8:y;12:image_file_size;16:inode_id 5绘制png4:x;8:y;12:image_file_size;16:inode_id + nic 说明 该设备可以理解为对socket的简化封装，也可以自己实现完整的计算机网络体系结构内容得到更高的网络带宽。 nic设备采用dma，直接操作ram。 地址空间 0x30200000 0x40200000 drivers 0x30200000为控制寄存器地址 写入信号对应功能数据寄存器功能与地址偏移 1accept0 16:ip;20:port;24:protocol;28:return sockfd 2send4:sockfd;8:send_data_ram_addr;12:data_len 3recv4:sockfd;8:send_data_ram_addr;12:data_len 4connect0 16:ip;20:port;24:protocol;28:return sockfd 5close4:sockfd + flash 地址空间 0x40200000 0x60200000 + pmc 地址空间 0x60200000 0x60300000 driver 0x60200000为控制寄存器，向该地址写入任何信号都会触发关机。 + monitor 地址空间 0x60300000 0x60400000 drivers 0x60300000为控制寄存器地址 当向控制寄存器地址写入1时触发监测器的启动，此时开始进行性能数据的采集。 写入1后写入0，将会触发监测器的关闭，并将数据存储至宿主机。"},"/docs/tutorial/blkrv/进阶/寄存器/index.html":{"title":"CPU寄存器详解","content":"# CPU寄存器详解 ## 通用寄存器 寄存器别名全称说明 X0\tzero\t零寄存器\t可做源寄存器(rs)或目标寄存器(rd) X1\tra\t链接寄存器\t保存函数返回地址 X2\tsp\t栈指针寄存器\t指向栈的地址 X3\tgp\t全局寄存器\t用于链接器松弛优化（blkos中未启用） X4\ttp\t线程寄存器\t常用于在OS中保存指向进程控制块(task_struct)数据结构的指针（blkos中未启用） X5 ~ X7，X28 ~ X31\tt0 ~ t6\t临时寄存器\t X8\ts0/fp\t帧指针寄存器\t用于函数调用，被调用函数需保存数据 X9\ts1\t\t用于函数调用 ，被调用函数需要保存的数据 X10 ~ X17\ta0 ~ a7\t\t用于函数调用，传递参数和返回值 X18 ~ X27\ts2 ~ s11\t\t用于函数调用 ，被调用函数需要保存的数据 ## CSR寄存器 寄存器别名全称说明 c305mtvecMachine Trap Vector Base Address用于保存中断查询程序地址，需要在系统初始化时通过csr指令赋值 c341mepcMachine Exception Program Counter用于保存发生中断时，程序执行的pc，也就是中断地址 c342mcauseMachine Cause保存中断发生的原因，此处保存的是发生中断的端口 c300mstatusMachine Statusblkrv中该寄存器仅作为中断使能状态寄存器，低8位是否为1代表是否使能 c180satpSupervisor Address Translation and Protection Register保存页表基址 c181satp_s_cp发生系统调用时，保存satp副本 c182satp_i_cp发生中断调用时，保存satp副本 ## 流水寄存器 寄存器全称说明 pcProgram counter用于保存当前执行指令的地址 imm用于保存解析指令时产生的立即数 addr_vvirtual address用于保存LOAD/STORE指令等指向的地址 data2regs用于保存需要存储到通用寄存器的数据 data2mem用于保存需要存储到内存的数据 instinstruction用于保存读取的指令"},"/docs/tutorial/c++/cmake/index.html":{"title":"cmake","content":"# cmake ## 相关指令功能 ### set 功能：设置变量 用法： 1,一般变量 `set(normal \"normalValue\")` 2,缓存变量 ```cmake set(MY_VARIABLE \"Hello, World!\" CACHE STRING \"A greeting message\" FORCE) message(\"${MY_VARIABLE}\") # 输出Hello, World! set(MY_VARIABLE \"Good Morning!\" CACHE STRING \"A greeting message\") message(\"${MY_VARIABLE}\") # 输出Hello, World!因为不加FORCE默认不覆盖 set(MY_VARIABLE \"Good Morning!\" CACHE STRING \"A greeting message\" FORCE) message(\"${MY_VARIABLE}\") # 输出Good Morning! 加了FORCE强制覆盖 ``` 存储在CMakeCache当中，可以跨越多次编译，持久化存储。 3,环境变量 `set(ENV{<variable>} [<value>])` `unset(ENV{<variable>})` ```cmake # 设置一个名为 MY_VARIABLE 的环境变量，其值为 Hello World： set(ENV{MY_VARIABLE} \"Hello World\") ``` 可以用于在不同cmakelist之间传递变量，但是不可持久化储存 ### file 1,READ 读取文件（filename）的内容保存到变量（variable）中； file(READ config.cmake contents) 2,STRINGS 解析filename中的ASCII字符串列表，并将其存储在中。忽略文件中的二进制数据。忽略回车(\\r, CR)字符； ### execute_process 通过execute_process方法可以执行多个子进程。 命令COMMAND会并行执行，每个子进程的标准输出映射到下一个进程的标准输入上，所有进程共用standard error管道。 `execute_process(COMMAND rm rf ${ASCEND_AUTOGEN_PATH}/${CUSTOM_COMPILE_OPTIONS} COMMAND touch ${ASCEND_AUTOGEN_PATH}/${CUSTOM_COMPILE_OPTIONS})` ### function ```cmake function(<name> [<arg1> ...]) <commands> endfunction([<name>]) ``` ```cmake function(get_system_info SYSTEM_INFO) if (UNIX) execute_process(COMMAND grep i ^id /etc/os release OUTPUT_VARIABLE TEMP) elseif (WIN32) message(STATUS \"System is Windows. Only for pre build.\") else () message(FATAL_ERROR \"${CMAKE_SYSTEM_NAME} not support.\") endif () endfunction() ``` ### string 操作字符串 [具体教程](https://zhuanlan.zhihu.com/p/661283261) ### $<...> 1,检查变量 SOC_VERSION 的值是否在列表 CUSTOM_ASCEND310P_LIST 中 2,将上一步的结果强制转换为布尔类型（0 或 1） 3,如果条件为 True，则返回值 CUSTOM_ASCEND310P；否则不返回任何内容。 ```cmake ascendc_compile_definitions(ascendc_kernels_${RUN_MODE} PRIVATE $<$<BOOL:$<IN_LIST:${SOC_VERSION},${CUSTOM_ASCEND310P_LIST}>>:CUSTOM_ASCEND310P> ) ``` ### get_filename_component get_filename_component 函数用于获取文件名或目录的各个部分，如文件名、扩展名、目录等。 ```cmake get_filename_component(filename ${filepath} NAME) get_filename_component(directory ${filepath} DIRECTORY) message(STATUS \"File Name: ${filename}\") message(STATUS \"Directory: ${directory}\") ``` ### ExternalProject ExternalProject是CMake提供的另一个模块，用于在构建时下载、配置、构建和安装外部项目（即不是作为当前CMake项目一部分的项目）。 ExternalProject模块通过以下主要步骤实现其功能： 1. 下载源代码：在构建过程中下载外部项目的源代码。可以指定URL、Git仓库、SVN仓库等多种来源。 2. 配置项目：对下载的外部项目进行配置，包括设置构建选项和参数。 3. 构建项目：构建外部项目，生成需要的二进制文件或库。 4. 安装项目：将构建的项目安装到指定位置，以便于主项目使用。 基本步骤： 1. 引入ExternalProject模块： 在CMakeLists.txt文件中使用include(ExternalProject)命令来启用ExternalProject模块的功能。 2. 声明外部项目： 使用ExternalProject_Add函数声明一个外部项目，指定其源代码来源、配置选项、构建命令、安装位置等。 3. 配置依赖关系（可选）： 如果外部项目依赖于其他项目或特定的构建步骤，可以使用add_dependencies命令来配置这些依赖关系。 4. 使用安装的依赖： 一旦外部项目被构建和安装，其产物（如库、可执行文件等）就可以在主项目中被使用。 ### add_library 编译生成库文件 ### target_compile_options target_compile_options 指令用于为指定的目标添加编译器选项。通过这些选项，可以影响编译器如何处理目标的源代码。"},"/docs/tutorial/c++/fltk/index.html":{"title":"","content":"# fltk"},"/docs/tutorial/c++/makefile/index.html":{"title":"Makefile 教程","content":"# Makefile 教程 仅仅是零碎知识点 ## 变量命名 ```makefile var: variable $(var) ``` ## 获取指定文件夹所有文件"},"/docs/tutorial/index.html":{"title":"some tutorials about the configure","content":"# some tutorials about the configure some tutorials about the configure > **click the sidebar to open markdown file** >! [read from the first file](./blkrv/fltk/fltk.html)"},"/docs/tutorial/somethingInteresting/officeAi/index.html":{"title":"officeAi 插件","content":"# officeAi 插件 ## src [download here](./OfficeAI.exe)"},"/docs/tutorial/writing/index.html":{"title":"论文写作注意","content":"# 论文写作注意 ## 重视写作 给别人讲明白自己的idea ## 英文写作 英文论文阅读 减少辅助工具的使用 领域内专有名字，深度绑定第一个问题。 ## 观点 和图配合，论述清楚自己的观点。 缩写等先定义再使用，不要默认审稿人知道相关领域知识。 ## 用词准确 用词不标准，cache ratio，cache rate 用词不形象，动词的选择等。 ## 画图不严谨 缺少信息 图中重点表达模糊 ## 详略不当 没有一个凝练的写作思路，没有大纲。论文中出现的每一段最好都有意义。 强调为什么要这么做，比啰啰嗦嗦讲怎么做更重要。 ## 矢量图 放大不失真 字体统一，格式相关问题。 文章时态位一般现在时 ![alt text](image.png)"}}